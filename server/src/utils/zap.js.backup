const mime = require('mime-types');
const fs = require('fs');
const axios = require('axios');
const moment = require('moment');
const path = require('path');
const { parsePhoneNumberFromString } = require('libphonenumber-js');

const { getIO } = require('../socket');
const io = getIO();

const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');

const dbQuery = require('./dbHelper');
const { exec } = require('child_process');
const { handleIncomingMessage } = require('./flowEngine');
const { getAgendamentos } = require('./agendaUtils');

function formatarMensagemHTML(mensagem) {
    if (!mensagem) return '';

    return mensagem
        .replace(/\*(.*?)\*/g, '<strong>$1</strong>')       // *negrito*
        .replace(/_(.*?)_/g, '<em>$1</em>')                 // _itálico_
        .replace(/~(.*?)~/g, '<s>$1</s>')                   // ~riscado~
        .replace(/\n/g, '<br>');                            // quebras de linha
}

function formatHtmlMensagem(mensagem) {
    if (!mensagem) return '';

    return mensagem
        .replace(/<strong>(.*?)<\/strong>/g, '*$1*')       // <strong>negrito</strong>
        .replace(/<em>(.*?)<\/em>/g, '_$1_')               // <em>itálico</em>
        .replace(/<s>(.*?)<\/s>/g, '~$1~')                 // <s>riscado</s>
        .replace(/<br>/g, '\n');                           // <br> quebras de linha
}

const handleMidia = async (midia, numero) => {
    if (!midia) return null;

    let mime = midia.mimetype;
    let base64 = midia.data;
    let fileName = midia.filename;
    let filesize = midia.filesize;
    let ext = mime.split('/')[1];
    let type = mime.split('/')[0];
    if (ext.includes(';')) {
        ext = ext.split(';')[0];
    }
    if (!fileName) {
        const numberAleatorio = Math.floor(Math.random() * 1000000);

        fileName = `${numero}-${moment().format('YYYYMMDDHHmmss')}-${numberAleatorio}.${ext}`;
    }

    //('Mídia - Mime:', mime, 'Nome:', fileName, 'Tamanho:', filesize);

    let caminhoBase = path.join(__dirname, `/uploads/midias/${numero}`);

    if (!fs.existsSync(caminhoBase)) {
        fs.mkdirSync(caminhoBase, { recursive: true });
    }

    let caminhoFile = path.join(caminhoBase, fileName);
    fs.writeFileSync(caminhoFile, base64, 'base64');
    //console.log('Mídia salva em:', caminhoFile);

    return {
        caminho: caminhoFile,
        url: `/uploads/midias/${numero}/${fileName}`,
        mime: mime,
        filename: fileName,
        filesize: filesize,
        ext: ext,
        type: type
    };

}

const mapearMsg = async (msg, save = true) => {
    if (!msg) return null;

    // //console.log('Mensagem:', msg._data.notifyName, msg._data);

    let midia = null;

    if (msg.hasMedia) {

        try {
            let dmidia = await msg.downloadMedia();

            if (dmidia) {
                if (save) {
                    midia = await handleMidia(dmidia, msg.from);

                    if (dmidia.mimetype?.includes('audio')) {
                        midia.duration = msg.duration;
                    }
                } else {
                    midia = {
                        url: '',
                        mime: dmidia.mimetype,
                        filename: dmidia.filename,
                        filesize: dmidia.filesize,
                    }

                    if (dmidia.mimetype?.includes('audio')) {
                        midia.duration = msg.duration;
                    }
                }
            }
        } catch (error) {
            console.error('Erro ao baixar mídia:', error);
        }
    }

    let resposta;
    if (msg.hasQuotedMsg) {
        let msgResposta = await msg.getQuotedMessage();

        resposta = await mapearMsg(msgResposta, true);
    }

    let mensagem = {
        id: msg.id._serialized,
        tipo: msg.type,
        texto: formatarMensagemHTML(msg.body),
        data: msg.timestamp ? moment.unix(msg.timestamp).format('DD/MM/YYYY HH:mm:ss') : null,
        lida: msg._data.viewed ? true : false,
        fromMe: msg.fromMe,
        hasMedia: msg.hasMedia,
        media: midia,
        senderName: msg._data.notifyName,
        ack: msg._data.ack,
        hasResposta: msg.hasQuotedMsg,
        resposta: resposta,
        raw: msg
    };

    return mensagem;
}

const usersJump = [
    '13135550002', '0'
]

const checkNameContato = (contato) => {
    if (!contato) return '';

    let nome = contato.name;

    //console.log('Nome contato:', nome, 'Contato Pushname:', contato.pushname);

    //Verificar se inicia com +55 ou 55
    if (!nome || nome.startsWith('+55') || nome.startsWith('55')) {
        nome = contato.pushname;
    }

    return nome;
}

// Create a new client instance
const client = new Client({
    authStrategy: new LocalAuth({
        dataPath: './session-zap',
    }),
    puppeteer: {
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
        executablePath: '/usr/bin/google-chrome-stable',
    }
});

let iniciando = false;

const checkInit = async () => {
    let checkValue = await dbQuery('SELECT * FROM Options WHERE type = "zap_conn"');
    if (checkValue.length === 0) {
        await dbQuery(`INSERT INTO Options (type, value) VALUES ('zap_conn', '0')`);
    }
    let value = checkValue[0].value ? JSON.parse(checkValue[0].value) : 0;
    console.log('Valor do zap_conn:', value);
    if (value == 1) {
        initZap();
    }
};

checkInit();

const cleanNumber = (number) => {
    if (!number) return '';
    return number.replace(/\D/g, '').replace(/^\+55/, '').replace(/^55/, '');
};

/**
 * Tenta resolver o chatId testando:
 *   1) número original (8 ou 9 dígitos)
 *   2) se não achou, remove o '9' (quando houver)
 *   3) se ainda não achou, adiciona o '9' (quando faltar)
 *
 * Usa apenas getNumberId, que retorna null ou o ID canônico.
 */
async function resolveChatId(rawNumber) {
    // 1) Extrai só dígitos
    const onlyDigits = rawNumber.replace(/\D+/g, '');

    // 2) Valida e pega nationalNumber (DDD + subscriber)
    const phoneObj = parsePhoneNumberFromString(onlyDigits, 'BR');
    if (!phoneObj || !phoneObj.isValid()) {
        throw new Error(`Número inválido: ${rawNumber}`);
    }
    const national = phoneObj.nationalNumber.toString(); // ex: "11976331280" ou "1112345678"
    const ddd = national.slice(0, 2);             // ex: "11"
    const subscriber = national.slice(2);                // ex: "976331280" ou "12345678"

    // 3) Prepara lista de variações a testar
    const candidates = [national];
    if (subscriber.length === 9 && subscriber.startsWith('9')) {
        candidates.push(ddd + subscriber.slice(1));         // remove nono dígito
    } else if (subscriber.length === 8) {
        candidates.push(ddd + '9' + subscriber);            // adiciona nono dígito
    }

    // 4) Tenta cada candidato com getNumberId
    for (let cand of candidates) {
        const e164 = `55${cand}`;                           // ex: "5511976331280" ou "551176331280"
        console.log(`→ Testando: ${e164}`);

        // getNumberId aceita string sem "@c.us" e acrescenta sozinho
        const contactId = await client.getNumberId(e164);
        if (contactId) {
            // contactId.user = "551176331280", contactId.server = "c.us"
            console.log(`✔ Encontrou no WhatsApp: ${contactId.user}@${contactId.server}`);
            return `${contactId.user}@${contactId.server}`;
        }
    }

    throw new Error(`Número não registrado no WhatsApp: ${rawNumber}`);
}

async function initZap() {
/*     if (process.env.NODE_ENV !== 'dev') {
        return;
    }
 */
    try {
        if (iniciando) {
            //console.log('Já está iniciando o cliente do WhatsApp...');
            return;
        }

        iniciando = true;

        console.log('Iniciando cliente do WhatsApp...');

        let checkValue = await dbQuery('SELECT * FROM Options WHERE type = "zap_conn"');
        let value = checkValue[0].value ? JSON.parse(checkValue[0].value) : 0;
        if (value == 1) {
            await dbQuery(`UPDATE Options SET value = ${JSON.stringify("0")} WHERE type = "zap_conn"`);
        }

        // When the client is ready, run this code (only once)
        client.once('ready', () => {
            console.log('Client is ready!');
        });

        client.on('qr', (qr) => {
            console.log('QR RECEIVED', qr);
            io.emit('qr', qr);
        });

        client.on('authenticated', async () => {
            console.log('AUTHENTICATED');
            await dbQuery(`UPDATE Options SET value = ${JSON.stringify("1")} WHERE type = "zap_conn"`);
            io.emit('autentica-zap', 'Autenticado com sucesso!');
        });

        client.on('auth_failure', msg => {
            console.error('AUTHENTICATION FAILURE', msg);
            io.emit('autentica-error-zap', 'Houve um erro na autenticação! Tente novamente.');
        });

        client.on('disconnected', async (reason) => {
            console.log('Client was logged out', reason);
            await dbQuery(`UPDATE Options SET value = ${JSON.stringify("0")} WHERE type = "zap_conn"`);
            io.emit('desconectado-zap', 'WhatsApp desconectado!');
        });

        client.on('message_create', async (message) => {
            const chat = await message.getChat();

            if (chat && !chat.isGroup && chat.id.server === 'c.us'
                && !usersJump.includes(chat.id.user)) {

                const mappedMsg = await mapearMsg(message, true);

                if (mappedMsg) {
                    mappedMsg.idChat = chat.id._serialized;

                    //console.log('Mensagem recebida:', mappedMsg);

                    // Enviar a mensagem para o socket
                    io.emit('nova-mensagem', mappedMsg);

                    // integra ao motor de fluxos quando houver mensagem do usuário (não do sistema)
                    if (!message.fromMe) {
                        try {
                            const phone = chat.id.user; // 55DDDNÚMERO
                            await handleIncomingMessage({ phone, chatId: chat.id._serialized, text: message.body || '' });
                        } catch (e) {
                            console.error('flowEngine incoming error:', e.message);
                        }
                    }
                } else {
                    //console.log('Mensagem não mapeada:', message);
                }
            }
        });

        //Ouvinte de mensagens criadas/recebidas/enviadas
        /*  client.on('message_create', async (message) => {
             //console.log('Mensagem criada:', message);
         }); */

        /*
        * Evento para ouvir status de mensagens
        * Status possíveis: 
        * 0: A mensagem foi enviada, mas ainda não chegou ao servidor (pendente).
        * 1: A mensagem foi recebida pelo servidor do WhatsApp.
        * 2: A mensagem foi entregue ao destinatário.
        * 3: A mensagem foi lida pelo destinatário (status de "lida").
        */

        client.on('message_ack', async (message, ack) => {
            io.emit('update-mensagem', { id: message.id._serialized, ack: ack });
        });

        client.on('message_edit', async (message) => {
            //console.log('Mensagem editada:', message);
            io.emit('update-mensagem', { id: message.id._serialized, texto: formatarMensagemHTML(message.body) });
        });

        /*  client.on('message_ack', async (message, ack) => {
             //console.log('Status de mensagem:', ack, 'Mensagem:', message);
         }); */

        // Start your client
        client.initialize();

        iniciando = false;
    } catch (error) {
        console.error('Erro ao iniciar cliente do WhatsApp:', error);
        iniciando = false;
    }
}

function formatPhoneNumber(number) {
    // Remove todos os caracteres não numéricos
    const cleaned = ('' + number).replace(/\D/g, '');
    // Verifique se o número começa com o código do país
    if (cleaned.startsWith('55')) {
        return cleaned + '@c.us';
    }
    return '55' + cleaned + '@c.us';
}


async function sendZapMessage(number, message) {
    try {

        const options = await dbQuery('SELECT * FROM Options');

        if (options.length > 0) {
            let devMode = options.filter(option => option.type == 'modo_dev')[0].value;

            //console.log('Modo dev:', devMode);

            if (devMode == "true") {
                let numerosDev = options.filter(option => option.type == 'numeros_dev')[0].value;

                if (numerosDev && typeof numerosDev == 'string') {
                    numerosDev = JSON.parse(numerosDev);
                }

                //console.log('Números de dev:', numerosDev);

                if (numerosDev && numerosDev.length > 0) {
                    let numeros = numerosDev.map((number) => {
                        return cleanNumber(number);
                    });

                    //console.log('Números de dev clean:', numeros);
                    //console.log('Número cliente:', number);
                    if (!numeros.includes(cleanNumber(number))) {
                        ////console.log('Número não está na lista de dev:', cliente.phone);

                        //cliente.phone = numeros[0];
                        // return;

                        //console.log('Número não está na lista de dev:', number, 'enviando para os números de dev:', numeros);

                        for (let i = 0; i < numeros.length; i++) {
                            let numero = numeros[i];

                            //console.log('Enviando mensagem para', numero, 'com o texto:', message);

                            // Formata o número de telefone no formato internacional

                            const rawNumber = formatPhoneNumber(numero);
                            const chatId = await resolveChatId(rawNumber);

                            // Envia a mensagem
                            try {
                                await client.sendMessage(chatId, message);
                            } catch (error) {
                                console.error('Erro ao enviar mensagem (catch):', error);
                            }

                            //console.log('Mensagem enviada com sucesso para', numero);

                            // Aguarda 5 segundos entre os envios
                            if (i < numeros.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 5000));
                            }
                        }

                        //console.log('Mensagem enviada para todos os números de dev com sucesso!');

                        return true;
                    }
                } else {
                    //console.log('Nenhum número de dev encontrado!');
                    return false;
                }
            }
        }

        //console.log('Enviando mensagem para', number, 'com o texto:', message);

        // Formata o número de telefone no formato internacional
        const rawNumber = formatPhoneNumber(number);
        const chatId = await resolveChatId(rawNumber);

        // Envia a mensagem
        try {
            await client.sendMessage(chatId, message);
        } catch (error) {
            console.error('Erro ao enviar mensagem (catch):', error);
        }

        //console.log('Mensagem enviada com sucesso para', number);

        return true;
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);

        const errMsg = error?.message || '';
        if (errMsg.includes('Session closed') || errMsg.includes('Most likely the page has been closed')) {
            console.error('⚠️ Página já foi fechada, iniciando cliente novamente...');

            // Inicia o cliente novamente
            checkInit();

            //Aguardar 10 segundos para tentar enviar novamente
            await new Promise(resolve => setTimeout(resolve, 15000));

            return await sendZapMessage(number, message);
        }

        return false;
    }
}

async function sendZapMessageImage(number, message, imagePath) {
    try {
        //console.log('Enviando mensagem para', number, 'com o texto:', message, 'e imagem:', imagePath);

        const options = await dbQuery('SELECT * FROM Options');

        if (options.length > 0) {
            let devMode = options.filter(option => option.type == 'modo_dev')[0].value;

            //console.log('Modo dev:', devMode);

            if (devMode == "true") {
                let numerosDev = options.filter(option => option.type == 'numeros_dev')[0].value;

                if (numerosDev && typeof numerosDev == 'string') {
                    numerosDev = JSON.parse(numerosDev);
                }

                //console.log('Números de dev:', numerosDev);

                if (numerosDev && numerosDev.length > 0) {
                    let numeros = numerosDev.map((number) => {
                        return cleanNumber(number);
                    });

                    //console.log('Números de dev clean:', numeros);
                    //console.log('Número cliente:', number);
                    if (!numeros.includes(cleanNumber(number))) {
                        ////console.log('Número não está na lista de dev:', cliente.phone);

                        //cliente.phone = numeros[0];
                        // return;

                        //console.log('Número não está na lista de dev:', number, 'enviando para os números de dev:', numeros);

                        for (let i = 0; i < numeros.length; i++) {
                            let numero = numeros[i];

                            //console.log('Enviando mensagem para', numero, 'com o texto:', message);

                            // Formata o número de telefone no formato internacional

                            const rawNumber = formatPhoneNumber(numero);
                            const chatId = await resolveChatId(rawNumber);

                            // Envia a mensagem
                            try {
                                await client.sendMessage(chatId, message);
                            } catch (error) {
                                console.error('Erro ao enviar mensagem (catch):', error);
                            }

                            //console.log('Mensagem enviada com sucesso para', numero);

                            // Aguarda 5 segundos entre os envios
                            if (i < numeros.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 5000));
                            }
                        }

                        //console.log('Mensagem enviada para todos os números de dev com sucesso!');

                        return true;
                    }
                } else {
                    //console.log('Nenhum número de dev encontrado!');
                    return false;
                }
            }
        }

        // Formata o número de telefone no formato internacional
        const rawNumber = formatPhoneNumber(number);
        const chatId = await resolveChatId(rawNumber);

        // Carrega a imagem e determina seu tipo MIME
        const image = fs.readFileSync(imagePath);

        if (!image) {
            console.error('Imagem não encontrada:', imagePath);
            return;
        }

        const filename = imagePath.split('/').pop();

        const mimeType = mime.lookup(imagePath);
        const media = new MessageMedia(mimeType, image.toString('base64'), filename);

        // Envia a mensagem com a imagem
        try {
            await client.sendMessage(chatId, media, { caption: message });
        } catch (error) {
            console.error('Erro ao enviar mensagem com imagem (catch):', error);
        }

        console.log('Mensagem com imagem enviada com sucesso para', number);

        return true;
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);

        const errMsg = error?.message || '';
        if (errMsg.includes('Session closed') || errMsg.includes('Most likely the page has been closed')) {
            console.error('⚠️ Página já foi fechada, iniciando cliente novamente...');

            // Inicia o cliente novamente
            checkInit();

            //Aguardar 10 segundos para tentar enviar novamente
            await new Promise(resolve => setTimeout(resolve, 15000));

            return await sendZapMessageImage(number, message, imagePath);
        }

        return false;
    }
}

// Função para obter todos os chats
async function getAllChats(limit = 5, page = 1, searchQuery = null, mapeado = true) {
    if (!client) return [];

    let checkValue = await dbQuery('SELECT * FROM Options WHERE type = "zap_conn"');
    let value = checkValue[0].value ? JSON.parse(checkValue[0].value) : 0;

    if (value == 0) {
        return [];
    }

    try {
        const offset = (page - 1) * limit;

        const chatsAll = await client.getChats();

        let chats = chatsAll.filter(chat => {
            if (chat.isGroup || chat.id.server !== 'c.us') {
                return false;
            }

            let numero = chat.id._serialized.replace('@c.us', '');
            let numeroClean = cleanNumber(numero);

            let isUserJump = usersJump.includes(numeroClean);
            if (isUserJump) {
                //console.log('Número encontrado na lista de usuários pulados:', numeroClean);
                return false;
            }

            let isValid = numeroClean.length >= 10 && numeroClean.length <= 15;
            if (!isValid) {
                //console.log('Número inválido:', numeroClean);
            }
            return isValid;
        });

        ////console.log('Chats Encontrados:', chats.length);

        if (!searchQuery || searchQuery == '') {
            chats = chats.slice(offset, offset + limit);
        } else {
            chats = chats.filter(chat => chat.name.toLowerCase().includes(searchQuery.toLowerCase())).slice(offset, offset + limit);
        }

        ////console.log('Chats filtrados:', chats.length);

        if (mapeado == 'false') {
            return chats;
        }

        for (let chat of chats) {
            ////console.log('Buscando contato:', chat.id);

            const contato = await chat.getContact();

            if (contato) {
                contato.avatar = await contato.getProfilePicUrl();
                chat.contact = contato;
                ////console.log('Contato:', contato.avatar);
            }

            ////console.log('Contato buscado chat:', chat.id);
        }

        const mappedChats = chats.map(async chat => {
            // //console.log('Mapeando chat:', chat.id._serialized);

            let numero = chat.id._serialized.replace('@c.us', '');

            let mapeado = {
                id: chat.id._serialized,
                pinned: chat.pinned,
                nome: chat.name,
                naoLida: chat.unreadCount,
                ultimaAcao: chat.timestamp ? moment.unix(chat.timestamp).format('DD/MM/YYYY HH:mm:ss') : null,
                contato: chat.contact ? {
                    id: chat.contact.id._serialized,
                    nome: checkNameContato(chat.contact),
                    numero: chat.contact.number,
                    avatar: chat.contact.avatar
                } : null,
                //dadosCliente: cliente,
                ultimaMensagem: await mapearMsg(chat.lastMessage, false),
                raw: chat
            };

            // //console.log('Chat mapeado:', mapeado);

            return mapeado;
        });


        //console.log('Mapeando chats:', mappedChats.length);

        const resolvedChats = await Promise.all(mappedChats);

        //console.log('Chats mapeados:', resolvedChats.length);

        return resolvedChats;
    } catch (error) {
        console.error('Erro ao obter os chats:', error);
        return [];
    }
}

// Função para obter todos os contatos
async function getAllContacts() {
    try {
        const contacts = await client.getContacts();
        return contacts;
    } catch (error) {
        console.error('Erro ao obter os contatos:', error);
        return [];
    }
}

function convertWebmToOgg(inputPath) {
    const outputPath = inputPath.replace(/\.webm$/i, '.ogg');
    return new Promise((resolve, reject) => {
        exec(
            `ffmpeg -i "${inputPath}" -vn -c:a libopus -b:a 64k -vbr on "${outputPath}"`,
            (err, stdout, stderr) => {
                if (err) return reject(new Error(stderr || err.message));
                resolve(outputPath);
            }
        );
    });
}

// Função para obter um único chat pelo ID
async function getChatById(chatId, mapeado = true, limit = 50) {
    if (!client) return null;

    let checkValue = await dbQuery('SELECT * FROM Options WHERE type = "zap_conn"');
    let value = checkValue[0].value ? JSON.parse(checkValue[0].value) : 0;
    if (value == 0) {
        //console.log('WhatsApp desconectado!');
        return null;
    }

    try {
        const chat = await client.getChatById(chatId);

        if (limit > 20) {
            let sync = await chat.syncHistory();

            //console.log('Sync history:', sync);
        }

        const contato = await chat.getContact();

        if (contato) {
            contato.avatar = await contato.getProfilePicUrl();
            chat.contact = contato;
        }

        const mensagens = await chat.fetchMessages({ limit: parseInt(limit) });

        if (!mensagens || mensagens.length === 0) {
            //console.log('Nenhuma mensagem encontrada no chat:', chatId);
            //return null;
        }

        //console.log('Mensagens encontradas no chat:', mensagens.length);

        if (mapeado == 'false') {
            return chat;
        }

        /*  for(let mensagem of mensagens) {
             const msgMapped = await mapearMsg(mensagem);
 
             //console.log('Mensagem mapeada:', msgMapped);
 
             mensagem = msgMapped;
         } */

        const messagesMap = await Promise.all(
            mensagens.map(async mensagem => {
                return await mapearMsg(mensagem, true);
            })
        );

        // Remove nulos e ordena por timestamp (caso não venha ordenado)
        const mensagensOrdenadas = messagesMap.filter(Boolean).sort((a, b) => {
            return moment(a.data, 'DD/MM/YYYY HH:mm:ss').unix() - moment(b.data, 'DD/MM/YYYY HH:mm:ss').unix();
        });

        const messagesComData = [];
        let ultimaData = null;

        for (let msg of mensagensOrdenadas) {
            const dataAtual = moment(msg.data, 'DD/MM/YYYY HH:mm:ss').format('DD/MM/YYYY');

            if (dataAtual !== ultimaData) {
                messagesComData.push({
                    tipo: 'data',
                    data: dataAtual
                });
                ultimaData = dataAtual;
            }

            messagesComData.push(msg);
        }

        let numeroSearch = cleanNumber(chat.contact.number);

        console.log('Número do contato:', numeroSearch);

        //Pegar os 8 últimos dígitos do número
        numeroSearch = numeroSearch.slice(-8);

        console.log('Número de busca:', numeroSearch);

        const sql = `
        SELECT c.*
        FROM CLIENTES c
        WHERE RIGHT(REGEXP_REPLACE(COALESCE(c.cli_celular, ''), '[^0-9]', ''), 8) = ?
        OR EXISTS (
                SELECT 1
                FROM JSON_TABLE(COALESCE(c.cli_contatos, '[]'),
                                '$[*]' COLUMNS(type VARCHAR(20) PATH '$.type',
                                            val  VARCHAR(64) PATH '$.value')) jt
                WHERE jt.type = 'phone'
                AND RIGHT(REGEXP_REPLACE(COALESCE(jt.val,''), '[^0-9]', ''), 8) = ?
        )
        LIMIT 1
        `;

        const clienteQuery = await dbQuery(sql, [numeroSearch, numeroSearch]);
        let cliente = null;

        if (clienteQuery && clienteQuery.length > 0) {
            cliente = clienteQuery[0];

            cliente.id = cliente.cli_Id;
            cliente.agendamentos = await getAgendamentos('SELECT * FROM AGENDAMENTOS WHERE cli_id = ?', [cliente.cli_Id]);
            cliente.endereco = await dbQuery('SELECT * FROM ENDERECO WHERE cli_id = ?', [cliente.cli_Id]);
            cliente.nome = cliente.cli_nome;
            cliente.email = cliente.cli_email;
            cliente.cpf = cliente.cli_cpf;
            cliente.personType = cliente.cli_personType;
            cliente.genero = cliente.cli_genero;
            cliente.contatos = cliente.cli_contatos ? JSON.parse(cliente.cli_contatos) : [];
            cliente.tags = cliente.cli_tags ? JSON.parse(cliente.cli_tags) : [];
        }

        const mappedChat = {
            id: chat.id._serialized,
            pinned: chat.pinned,
            nome: chat.name,
            naoLida: chat.unreadCount,
            ultimaAcao: chat.timestamp ? moment.unix(chat.timestamp).format('DD/MM/YYYY HH:mm:ss') : null,
            contato: chat.contact ? {
                id: chat.contact.id._serialized,
                nome: checkNameContato(chat.contact),
                numero: chat.contact.number,
                avatar: chat.contact.avatar
            } : null,
            ultimaMensagem: await mapearMsg(chat.lastMessage),
            messagens: messagesComData,
            cliente: cliente,
            limit: limit,
            raw: chat
        };

        let see = await chat.sendSeen();

        //console.log('Send seen:', see);

        /*  let sync = await chat.syncHistory();
 
         //console.log('Sync history:', sync); */

        return mappedChat;
    } catch (error) {
        console.error('Erro ao obter o chat:', error);
        return null;
    }
}

async function sendMessageChat(chatId, message, idReply = null, midiaPath = null) {
    if (!client) return false;

    let checkValue = await dbQuery('SELECT * FROM Options WHERE type = "zap_conn"');
    let value = checkValue[0].value ? JSON.parse(checkValue[0].value) : 0;
    if (value == 0) {
        //console.log('WhatsApp desconectado!');
        return false;
    }

    if (!chatId || !message && !midiaPath) {
        //console.log('Chat ID ou mensagem não fornecidos!');
        return false;
    }

    if (midiaPath && !message) {
        message = ''
    }

    try {

        // Envia a mensagem
        if (!midiaPath) {
            if (!idReply) {
                try {
                    await client.sendMessage(chatId, message);
                } catch (error) {
                    console.error('Erro ao enviar mensagem (catch):', error);
                }
            } else {
                const messageReplay = await client.getMessageById(idReply);

                if (!messageReplay) {
                    //console.log('Mensagem não encontrada para resposta:', idReply);
                    return false;
                }

                await messageReplay.reply(message);
            }
        } else {
            // para array de attachments
            const paths = Array.isArray(midiaPath) ? midiaPath : [midiaPath];

            for (let p of paths) {
                let filePath = p;
                const mimeTypeInit = mime.lookup(filePath) || '';

                //console.log('Mídia - Mime 1:', mimeTypeInit, 'Caminho:', filePath);

                // se for webm, primeiro converte para ogg/opus
                if (mimeTypeInit === 'audio/webm' || /\.webm$/i.test(filePath)) {
                    filePath = await convertWebmToOgg(filePath);
                }

                // lê o buffer e converte para base64
                const buffer = fs.readFileSync(filePath);
                const base64 = buffer.toString('base64');
                const filename = path.basename(filePath);
                const mimeType = mime.lookup(filePath) || 'application/octet-stream';

                //console.log('Mídia - Mime:', mimeType, 'Nome:', filename);

                const media = new MessageMedia(mimeType, base64, filename);

                // envia como voz se for ogg
                if (mimeType === 'audio/ogg') {
                    if (!idReply) {
                        try {
                            await client.sendMessage(chatId, media, { sendAudioAsVoice: true, caption: message });
                        } catch (error) {
                            console.error('Erro ao enviar mensagem (catch):', error);
                        }
                    } else {
                        const messageReplay = await client.getMessageById(idReply);

                        if (!messageReplay) {
                            //console.log('Mensagem não encontrada para resposta:', idReply);
                            return false;
                        }

                        try {
                            await client.sendMessage(chatId, media, {
                                sendAudioAsVoice: true,           // ou caption, se for imagem/doc
                                quotedMessageId: messageReplay.id._serialized
                            });
                        } catch (error) {
                            console.error('Erro ao enviar mensagem (catch):', error);
                        }
                    }
                } else {
                    //await client.sendMessage(chatId, media, { caption: message });
                    if (!idReply) {
                        try {
                            await client.sendMessage(chatId, media, { caption: message });
                        } catch (error) {
                            console.error('Erro ao enviar mensagem (catch):', error);
                        }
                    } else {
                        const messageReplay = await client.getMessageById(idReply);

                        if (!messageReplay) {
                            //console.log('Mensagem não encontrada para resposta:', idReply);
                            return false;
                        }

                        //await messageReplay.reply(media, { caption: message });
                        try {
                            await client.sendMessage(chatId, media, {
                                caption: message,
                                quotedMessageId: messageReplay.id._serialized
                            });
                        } catch (error) {
                            console.error('Erro ao enviar mensagem (catch):', error);
                        }
                    }
                }

                // aguarda 2s entre envios (ajuste se quiser)
                await new Promise(res => setTimeout(res, 2000));
            }
        }
        //console.log('Mensagem enviada com sucesso para', chatId);

        return true;
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);

        return false;
    }
}

async function actionsChat(chatId, action) {
    if (!client || !chatId || !action) return false;

    let checkValue = await dbQuery('SELECT * FROM Options WHERE type = "zap_conn"');
    let value = checkValue[0].value ? JSON.parse(checkValue[0].value) : 0;
    if (value == 0) {
        //console.log('WhatsApp desconectado!');
        return false;
    }
    try {
        const chat = await client.getChatById(chatId);

        if (!chat) {
            //console.log('Chat não encontrado:', chatId);
            return false;
        }

        switch (action) {
            case 'markAsRead':
                await chat.sendSeen();
                //console.log('Chat marcado como lido:', chatId);
                break;
            case 'markAsUnread':
                await chat.markUnread();
                //console.log('Chat marcado como não lido:', chatId);
                break;
            case 'delete':
                await chat.delete();
                //console.log('Chat excluído:', chatId);
                break;
            case 'unpin':
                await chat.unpin();
                //console.log('Chat desfixado:', chatId);
                break;
            case 'pin':
                await chat.pin();
                //console.log('Chat fixado:', chatId);
                break;

            default:
                //console.log('Ação inválida:', action);
                return false;
        }

        return true;
    } catch (error) {
        console.error('Erro ao executar ação no chat:', error);
        return false;
    }
}

async function actionsMsg(messageId, action, dados = null) {
    if (!client || !messageId || !action) return false;

    let checkValue = await dbQuery('SELECT * FROM Options WHERE type = "zap_conn"');
    let value = checkValue[0].value ? JSON.parse(checkValue[0].value) : 0;
    if (value == 0) {
        //console.log('WhatsApp desconectado!');
        return false;
    }
    try {
        const message = await client.getMessageById(messageId);

        if (!message) {
            //console.log('Mensagem não encontrada:', messageId);
            return false;
        }

        switch (action) {
            case 'deleteMe':
                await message.delete();
                //console.log('Mensagem excluída:', messageId);
                break;
            case 'deleteTodos':
                await message.delete(true);
                //console.log('Mensagem excluída para todos:', messageId);
                break;
            case 'edit':
                if (!dados || !dados.conteudo || message.hasMedia) {
                    //console.log('Conteúdo não fornecido para edição da mensagem:', messageId);
                    return false;
                }

                let editar = await message.edit(dados.conteudo);

                //console.log('Edição da mensagem:', editar);
                break;
            default:
                //console.log('Ação inválida:', action);
                return false;
        }

        return true;
    } catch (error) {
        console.error('Erro ao executar ação na mensagem:', error);
        return false;
    }
}

module.exports = {
    initZap, sendZapMessage,
    sendZapMessageImage, getAllChats,
    getAllContacts, getChatById, sendMessageChat,
    actionsChat, actionsMsg
};
